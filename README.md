# Food Facilities Backend Challenge

The goal of this project is to provide an API to interact with data related to Mobile Food Facilities in San Francisco. The application allows you to:

- Search by the name of the applicant with an optional filter on the "Status" field.
- Search by street name (you can type part of the address).
- Given a latitude and longitude, get the 5 nearest food trucks. By default, this returns food trucks with status "APPROVED", but you can override this and search for all statuses.

## Getting Started

### Prerequisites

- Python 3.7 or later
- pipenv
- Postgresql

### Installation

1. Clone the repository
2. Install dependencies using pipenv:

  ```bash
  pipenv install
  pipenv shell
  ```

3. Set up your environment variables as follows:

  ```bash
  DATABASE_URL= # Your database URL
  SCHEMA= # Your database schema
  ENV= # Your environment (e.g. development, production, etc.)
  SECRET_KEY= # Your secret key for JWT token
  ALGORITHM=HS256
  ACCESS_TOKEN_EXPIRE_MINUTES= # Token expiry in minutes
  POSITIONSTACK_API_KEY= # Your PositionStack API key -> https://positionstack.com/signup/free
  ```

4. Build tables:

  ```
  alembic upgrade head
  ```

5. Seed the database:

  ```
  python -m db.seeds.seed seed
  ```

To undo the seed:

  ```
  python -m db.seeds.seed undo
  ```

6. Start the server:

  ```
  uvicorn main:app --reload
  ```
## API Documentation
The API documentation for this application is automatically generated by FastAPI's built-in support for OpenAPI. OpenAPI (formerly known as Swagger) is a specification for machine-readable interface files for describing, producing, consuming, and visualizing RESTful web services.

Once you have started the application, you can access the API documentation by navigating to the /docs endpoint in your web browser. If the application is running locally, this would typically be http://localhost:8000/docs.

The OpenAPI interface provides an interactive exploration of all the available API endpoints directly from your browser. It is a fast way to test, debug, and familiarize yourself with the API.

## Geospatial Search Implementation: Haversine Formula Over PostGIS

In this application, I've implemented geospatial querying using the Haversine Formula. This approach calculates the distances between latitude-longitude pairs, which I found to be simple, easier to understand, and didn't introduce additional dependencies. While aware of the scalability trade-offs for larger data sets and complex geospatial queries, I found the Haversine Formula to be a good fit for the current project scope.

## Geospatial Data Seeding: PositionStack API
I used the PositionStack API to fetch missing latitude and longitude data during the seeding process automatically. This ensured that no valuable data was omitted due to incomplete geospatial information.

I chose PositionStack for its reliable large volume of free requests and reliability, but I'm aware that for larger datasets or in production, considerations like API rate limiting, data accuracy, and error handling would need to be addressed.

## Testing

Automated tests are included. To run the tests, use the following command:
  ```
  pytest
  ```

## Future Improvements and Scaling Considerations

While the current application serves the purpose well, there are several areas that could be improved or expanded in the future:

1. **Geospatial Querying**: As data grows in size and complexity of geospatial queries increases, a more advanced tool like PostGIS could be employed for efficient geospatial querying. This would provide better performance and more flexibility for complex spatial queries.

2. **Caching**: To improve the speed of commonly used queries, a caching layer could be added. This would reduce the load on the database and provide faster responses to the user.

3. **Improved Error Handling and Validation**: While the application has basic error handling and validation, these could be expanded to provide more informative error messages and more rigorous validation of input data.

4. **Logging and Monitoring**: Adding comprehensive logging and monitoring would provide insights into the system's performance and help identify any issues or bottlenecks.

5. **API Rate Limiting**: As the application scales and user base grows, API rate limiting could be implemented to ensure fair usage and prevent abuse of the service.

6. **Integration with Additional APIs**: To enhance the functionality of the application, it could be integrated with additional APIs, such as weather APIs to provide information about the current weather at the location of a food truck.

7. **User Profiles**: If the application expands to include user accounts, features such as favoriting food trucks or saving searches could be added.

8. **Advanced Search Capabilities**: The search functionality could be improved to support more complex queries, such as searching for food trucks by cuisine, rating, or price level.

9. **Data Refresh and Sync Mechanisms**: As data about food trucks will change (new trucks, closed trucks, changed locations), mechanisms for refreshing and syncing the data would be essential to keep the app useful and accurate.


## Time Spent

Building this project was both a challenge and a learning opportunity. Although I had previous experience with FastAPI, this project involved implementing an API from scratch, including setting up authentication and integrating geospatial querying - a feature I hadn't worked on before. Given these new aspects, the development process was not continuous, but instead, I dedicated a few hours each day over several days. This intermittent approach allowed me to dive deep into certain areas of the project, conduct research, and experiment with different approaches.
